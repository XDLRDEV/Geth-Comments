# 底层数据库构建的流程(2)

 本文件主要记录启动节点后，从磁盘中读取数据库到内存上的过程

（new之前的过程暂时还有点不明白的，之后再添加）

创建一个以太坊项目

```go
// eth/backend.go 117行 
// 创建一个以太坊项目
// New creates a new Ethereum object (including the
// initialisation of the common Ethereum object)
func New(ctx *node.ServiceContext, config *Config) (*Ethereum, error){
    ...
	chainDb, err := ctx.OpenDatabaseWithFreezer("chaindata", config.DatabaseCache, config.DatabaseHandles, config.DatabaseFreezer, "eth/db/chaindata/")
	if err != nil {
		return nil, err
	}
	chainConfig, genesisHash, genesisErr := core.SetupGenesisBlockWithOverride(chainDb, config.Genesis, config.OverrideIstanbul, config.OverrideMuirGlacier)
    ...
}
```

打开leveldb数据库和freezer冷藏库，freezer冷藏库默认在chaindata目录下的ancient文件夹中。

```go
// node/service.go 56行
func (ctx *ServiceContext) OpenDatabaseWithFreezer(name string, cache int, handles int, freezer string, namespace string) (ethdb.Database, error) {
	if ctx.Config.DataDir == "" {
		return rawdb.NewMemoryDatabase(), nil
	}
	root := ctx.Config.ResolvePath(name)

	switch {
	case freezer == "":
		freezer = filepath.Join(root, "ancient")
	case !filepath.IsAbs(freezer):
		freezer = ctx.Config.ResolvePath(freezer)
	}
	return rawdb.NewLevelDBDatabaseWithFreezer(root, cache, handles, freezer, namespace)
}
```

先从存储中将leveldb和freezerdb读入到内存中，然后将两者的内容进行比较和调整。

```go
// core/rawdb/database.go 213行
// 在NewLevelDBDatabase的基础上添加了一个freezerdb
func NewLevelDBDatabaseWithFreezer(file string, cache int, handles int, freezer string, namespace string) (ethdb.Database, error) {
	kvdb, err := leveldb.New(file, cache, handles, namespace)
	if err != nil {
		return nil, err
	}
	frdb, err := NewDatabaseWithFreezer(kvdb, freezer, namespace)
	if err != nil {
		kvdb.Close()
		return nil, err
	}
	return frdb, nil
}

// core/rawdb/database.go 108行
// 带有freezer，给定的键值数据存储之上创建一个高级数据库，包含一个正常的键值数据库和一个freezerdb
func NewDatabaseWithFreezer(db ethdb.KeyValueStore, freezer string, namespace string) (ethdb.Database, error) {
	// Create the idle freezer instance
	frdb, err := newFreezer(freezer, namespace)
	if err != nil {
		return nil, err
	}
	// Since the freezer can be stored separately from the user's key-value database,
	// there's a fairly high probability that the user requests invalid combinations
	// of the freezer and database. Ensure that we don't shoot ourselves in the foot
	// by serving up conflicting data, leading to both datastores getting corrupted.
	//
	//   - If both the freezer and key-value store is empty (no genesis), we just
	//     initialized a new empty freezer, so everything's fine.
	//   - If the key-value store is empty, but the freezer is not, we need to make
	//     sure the user's genesis matches the freezer. That will be checked in the
	//     blockchain, since we don't have the genesis block here (nor should we at
	//     this point care, the key-value/freezer combo is valid).
	//   - If neither the key-value store nor the freezer is empty, cross validate
	//     the genesis hashes to make sure they are compatible. If they are, also
	//     ensure that there's no gap between the freezer and sunsequently leveldb.
	//   - If the key-value store is not empty, but the freezer is we might just be
	//     upgrading to the freezer release, or we might have had a small chain and
	//     not frozen anything yet. Ensure that no blocks are missing yet from the
	//     key-value store, since that would mean we already had an old freezer.

	// 如果创世哈希为空，则我们有一个新的键值存储，因此在此方法中无需进行验证。 
    // 如果创世哈希不为空，则需要将其与freezer内的内容进行比较。
	if kvgenesis, _ := db.Get(headerHashKey(0)); len(kvgenesis) > 0 {
        // 如果freezer不为空
		if frozen, _ := frdb.Ancients(); frozen > 0 {
			// 确保创世块匹配
			if frgenesis, _ := frdb.Ancient(freezerHashTable, 0); !bytes.Equal(kvgenesis, frgenesis) 
             {
				return nil, fmt.Errorf("genesis mismatch: %#x (leveldb) != %#x (ancients)", kvgenesis, frgenesis)
			}  
			// 确保kvdb和frdb是连续的，
			if kvhash, _ := db.Get(headerHashKey(frozen)); len(kvhash) == 0 {
                
				// 数据库中缺少冰柜限制之后的后续标头。
				if *ReadHeaderNumber(db, ReadHeadHeaderHash(db)) > frozen-1 {
					return nil, fmt.Errorf("gap (#%d) in the chain between ancients and leveldb", frozen)
				}
			}
			// 键值存储将继续从冷冻机停止的地方开始，可能有重复的块，但是一切正常，
		} else {
			// 如果冷冻室为空，确保没有从键值存储中移走任何东西，否则将丢失数据。 
             // 检查＃1块以确定是否冻结了以前的任何内容，但是仅使用创世块来处理数据库。
			if ReadHeadHeaderHash(db) != common.BytesToHash(kvgenesis) {
				// 此时键值存储中有除创世块之外的其他块，尝试取出number为1的区块
				if kvblob, _ := db.Get(headerHashKey(1)); len(kvblob) == 0 {
					return nil, errors.New("ancient chain segments already extracted, please set --datadir.ancient to the correct path")
				}
				// Block #1 仍在键值存储当中，正常。
			}
			// 到这里则此时最新的块还是创世区块
		}
	}
	// Freezer is consistent with the key-value database, permit combining the two
    // 开启一个线程来监听链的变化进展
	go frdb.freeze(db)

	return &freezerdb{
		KeyValueStore: db,
		AncientStore:  frdb,
	}, nil
}
```