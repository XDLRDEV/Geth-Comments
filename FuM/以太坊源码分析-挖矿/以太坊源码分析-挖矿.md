# 以太坊源码分析-挖矿

+ 在源码目录中，consensus提供了以太坊的一些共识算法，miner提供以太坊的区块创建和挖矿。
+ 在控制台输入的mine.start()等命令会通过/eth/api文件指向/miner/miner.go

```go
/* FuM:参数即挖矿所需协程数量 */
func (api *PrivateMinerAPI) Start(threads *int) error {
	if threads == nil {
		return api.e.StartMining(runtime.NumCPU())
	}
	return api.e.StartMining(*threads)
}
```

+ **挖矿(mine)**是指矿工节点互相竞争生成新区块以写入整个区块链获得奖励的过程。**共识(consensus)**是指区块链各个节点对下一个区块的内容形成一致的过程。在以太坊中, `miner`包向外提供挖矿功能，`consensus`包对外提供共识引擎接口。

### 挖矿

`miner`包主要由`miner.go` `worker.go`两个文件组成。

- `Miner` 负责与外部交互和高层次的挖矿控制。
- `worker` 负责低层次的挖矿控制。

#### 它们之间的联系

#### Miner

Miner的定义如下

```go
type Miner struct {
	mux      *event.TypeMux
	worker   *worker
	coinbase common.Address
	eth      Backend
	engine   consensus.Engine
	exitCh   chan struct{}

	canStart    int32 // can start indicates whether we can start the mining operation
	shouldStart int32 // should start indicates whether we should start after sync
}
```

各字段作用如下, 其中标有<sup>外</sup>的字段表示与Miner包外部有联系

- `mux` <sup>外</sup> 接收来自**downloader**模块的*StartEvent* *DoneEvent* *FailedEvent*事件通知。在网络中，不可能只有一个矿工节点,当**downloader**开始从其他节点同步Block时，我们就没有必要再继续挖矿了.
- `eth` <sup>外</sup> 通过该接口可查询后台`TxPool` `BlockChain` `ethdb`的数据.举例来说，作为矿工，我们在生成一个新的Block时需要从`TxPool`中取出`pending Tx`(待打包成块的交易),然后将它们中的一部分作为新的Block中的Transaction
- `engine` <sup>外</sup> 采用的共识引擎,目前以太坊公网采用的是`ethash`,测试网络采用`clique`.
- `worker` 对应的worker,从这里看出Miner和worker是一一对应的
- `coinbase` 本矿工的账户地址,挖矿所得的收入将计入该账户
- `canStart` 标识是否可以开始挖矿
- `should` 标识同步后是否应该开始挖矿

`miner.New()`创建一个Miner,它主要完成以下功能

- `Miner` 字段的**初始化**

- 使用**miner.newWorker()**创建一个 `worker`
- 启动**miner.update()** 线程.该线程等待mux上的来自 **downloader**模块的事件通知用来控制挖矿开始或停止

#### worker

`worker`成员比较多,其中部分成员的意义如下

- `mux` `engine` `eth` `coinbase` 这几项都来自于`miner`, 其中`mux`相对于Miner里的稍微有点不同, Miner里的`mux`是用来接收**downloader**的事件，而worker里用`mux`来向外部**发布**已经挖到新Block
- `txsCh` <sup>外</sup> 从后台`eth`接收新的Tx的Channel
- `chainHeadCh` <sup>外</sup> 从后台`eth`接收新的Block的Channel

`worker.newWorker()` 创建一个worker,它除了完成各个成员字段的初始化,还做了以下工作

- 向后台`eth`注册`txCh` `chainHeadCh` `chainSideCh`通道用来接收对应数据
- 启动**worker.update()** 线程.该线程等待上面几个外部Channel 并作出相应处理
- 下面四句开始进行挖矿操作

```go
go worker.mainLoop()
go worker.newWorkLoop(recommit)
go worker.resultLoop()
go worker.taskLoop()
```

`worker.mainLoop()`中的`w.newWorkCh`拿到数据，调用`w.commitNewWork`方法。

`w.commitNewWork`方法中做了以下事情

- 创建区块头
  - 新区块头的number等于父区块number+1
  - 调用core.CalcGasLimit方法，计算gas限额，代码比较简单，总的思路是如果父区块使用的gas大于父区块gasLimit的2/3，那么当前区块的gasLimit就会增加。
- 设置区块头的Coinbase，为出块奖励矿工做准备
- 设置出块难度
  - calcDifficultyHomestead 出块难度会以10万为单位，呈指数级增加
- 设置是否支持DAO事件，header.Extra
- 设置叔块makeCurrent
  - 创建env
  - 设置祖先和家族，这里还没有设置该区块的叔块
- 出块 w.commit
  - w.engine.Finalize
    - accumulateRewards 计算出块奖励，包括当前块和叔块，并写入到世界状态中
    - state.IntermediateRoot 设置最终状态header.Root
      - 创建Block,设置Block的交易信息, 叔块信息，header中的txHash,ReceiptHash,UncelHash
  - w.taskCh <-&task{receipts: receipts, state: s, block: block, createdAt: time.Now()}: 向taskCh中添加任务

`taskLoop`中的task := <-w.taskCh拿到数据，处理逻辑

- w.engine.SealHash(task.block.Header()) 计算header数据的RLP hash值，判断是否有相同的块已经在挖矿中了
- w.engine.Seal(w.chain, task.block, w.resultCh, stopCh) 传入w.resultCh管道，如果校验没问题，会向w.resultCh中插入数据
  - ethash.mine(block, id, nonce, abort, locals) 挖矿，挖矿成功后，会向参数中的locals管道中写入数据
    - hashimotoFull调用这个方法计算hash值，每次循环nonce++
    - 当取到合法的hash值时，重新组装区块，并插入到found也就是locals管道中
  - result = <-locals 读取管道中的数据，管道中的数据在插入到Seal中参数resultCh管道中

`resultLoop`中的block := <-w.resultCh:拿到数据

- stat, err := w.chain.WriteBlockWithState(block, receipts, task.state)将区块写到区块链中
- w.mux.Post(core.NewMinedBlockEvent{Block: block}) 向其他节点广播区块
- w.chain.PostChainEvents(events, logs) 为了节约资源，向其他节点广播区块头等简单信息

挖矿的实际操作在`/consensus/ethash/sealer.go` 中，其中`mine()`是PoW的计算，`seal()`实现共识算法，试图找到满足块难度要求的`nonce`。`consensus` 中的代码还没开始看，后面再解析